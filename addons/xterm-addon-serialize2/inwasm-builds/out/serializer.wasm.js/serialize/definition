{"def":{"name":"serialize","type":0,"mode":1,"srctype":"Clang-C","imports":{"env":{"memory":{}}},"exports":{},"compile":{"switches":["-Wl,-z,stack-size=0","-Wl,--stack-first"]},"code":"\n    /* write combined chars on JS side */\n    __attribute__((import_module(\"env\"), import_name(\"single_combined\"))) void* single_combined(unsigned short* dst, int x);\n    __attribute__((import_module(\"env\"), import_name(\"load_link\"))) void* load_link(unsigned short* dst, int link);\n\n    // FIXME: import mask values as template strings from JS\n    #define CODEPOINT_MASK    0x1FFFFF\n    #define IS_COMBINED_MASK  0x200000\n    #define HAS_CONTENT_MASK  0x3FFFFF\n    #define WIDTH_MASK        0xC00000\n    #define WIDTH_SHIFT       22\n\n    /* bit 1..8     blue in RGB, color in P256 and P16 */\n    #define BLUE_MASK         0xFF\n    #define BLUE_SHIFT        0\n    #define PCOLOR_MASK       0xFF\n    #define PCOLOR_SHIFT      0\n    \n    /* bit 9..16    green in RGB */\n    #define GREEN_MASK        0xFF00\n    #define GREEN_SHIFT       8\n  \n    /* bit 17..24   red in RGB */\n    #define RED_MASK          0xFF0000\n    #define RED_SHIFT         16\n  \n    /* bit 25..26   color mode: DEFAULT (0) | P16 (1) | P256 (2) | RGB (3) */\n    #define CM_MASK           0x3000000\n    #define CM_DEFAULT        0\n    #define CM_P16            0x1000000\n    #define CM_P256           0x2000000\n    #define CM_RGB            0x3000000\n  \n    /* bit 1..24  RGB room */\n    #define RGB_MASK          0xFFFFFF\n    #define COLOR_MASK        0x3FFFFFF   /* == CM_MASK | RGB_MASK */\n\n    /* fg flags:   bit 27..32 */\n    #define INVERSE           0x4000000\n    #define BOLD              0x8000000\n    #define UNDERLINE         0x10000000\n    #define BLINK             0x20000000\n    #define INVISIBLE         0x40000000\n    #define STRIKETHROUGH     0x80000000\n\n    /* bg flags:   bit 27..32 (upper 2 unused) */\n    #define ITALIC            0x4000000\n    #define DIM               0x8000000\n    #define HAS_EXTENDED      0x10000000\n    #define PROTECTED         0x20000000\n    \n    /* ext flags:   bit 27..32 (upper 3 unused) */\n    #define UNDERLINE_STYLE   0x1C000000\n    \n    /* underline style */\n    #define UL_NONE           0\n    #define UL_SINGLE         1\n    #define UL_DOUBLE         2\n    #define UL_CURLY          3\n    #define UL_DOTTED         4\n    #define UL_DASHED         5\n\n    typedef struct __attribute__((packed, aligned(4))) {\n      unsigned int content;\n      unsigned int fg;\n      unsigned int bg;\n    } Cell;\n\n    /**\n     * Optimized itoa implementation for unsigned short to utf16.\n     *\n     * Note: Clang compiles with the div instruction in wasm.\n     * Since tests with shift mul in source show no runtime difference,\n     * wasm engines prolly optimize the division on their own.\n     */\n    unsigned int *LUT100 = (unsigned int*) 256;\n\n    __attribute__((noinline))\n    unsigned short* itoa16(unsigned short n, unsigned short *dst) {\n      if (n < 10) {\n        *dst++ = n + 48;\n      } else if (n < 100) {\n        *(unsigned int*) dst = LUT100[n];\n        dst += 2;\n      } else if (n < 1000) {\n        int h = n / 100;\n        *dst++ = h + 48;\n        *(unsigned int*) dst = LUT100[n - h * 100];\n        dst += 2;\n      } else if (n < 10000) {\n        int h = n / 100;\n        *(unsigned int*) dst = LUT100[h];\n        *((unsigned int*) dst+1) = LUT100[n - h * 100];\n        dst += 4;\n      } else {\n        int h = n / 10000;\n        *dst++ = h + 48;\n        n -= h * 10000;\n        h = n / 100;\n        *(unsigned int*) dst = LUT100[h];\n        *((unsigned int*) dst+1) = LUT100[n - h * 100];\n        dst += 4;\n      }\n      return dst;\n    }\n\n    /* TODO: target support flags */\n    #define S_SGR         1     /* include SGR flags */\n    #define S_COLORS      2     /* include 256 indexed colors */\n    #define S_RGB         4     /* include RGB colors */\n    #define S_REMPTY      8     /* right truncate empty cells */\n    #define S_CURSOR      16    /* include cursor move sequences */\n    #define S_ALT_SWITCH  32    /* include normal buffer, if on alternate */\n    #define S_DECAWM      64    /* dont break soft wraps */\n\n\n    /**\n     * Set SGR colors for FG / BG / UL.\n     * c denotes the color target as {FG: '3', BG: '4', UL: '5'}.\n     */\n    __attribute__((noinline))\n    static unsigned short* set_color16(unsigned short *d, unsigned int v, char c) {\n      int mode = v & CM_MASK;\n      if (mode == CM_DEFAULT) {\n        *(unsigned long long*) d = 0x3b00390000ULL | c;\n        d += 3;\n      } else if (mode == CM_P16) {\n        unsigned long long color = 48 + (v & 7);\n        if (v & 8) {\n          /* bright for FG | BG (no UL color here) */\n          if (c == '3') {\n            *(unsigned long long*) d = 0x003b00000039ULL | color << 16;\n            d += 3;\n          } else if (c == '4') {\n            *(unsigned long long*) d = 0x003b000000300031ULL | color << 32;\n            d += 4;\n          }\n        } else {\n          /* handles normal FG | BG | UL */\n          *(unsigned long long*) d = 0x3b00000000ULL | color << 16 | c;\n          d += 3;\n        }\n      } else if (mode == CM_P256) {\n        *d++ = c;\n        *(unsigned long long*) d = 0x3b0035003b0038ULL;\n        d += 4;\n        d = itoa16(v & 0xFF, d);\n        *d++ = ';';\n      } else {\n        *d++ = c;\n        *(unsigned long long*) d = 0x3b0032003b0038ULL;\n        d += 4;\n        d = itoa16((v >> 16) & 0xFF, d);\n        *d++ = ';';\n        d = itoa16((v >> 8) & 0xFF, d);\n        *d++ = ';';\n        d = itoa16(v & 0xFF, d);\n        *d++ = ';';\n      }\n      return d;\n    }\n\n    // FIXME: any nicer way to express this?\n    #define SGR_FLAG(V, DIFF, FLAG, HI, LO)                     if ((DIFF) & (FLAG)) {                                        if ((V) & (FLAG)) {                                           *(unsigned int*) d = 0x3b0000 | (HI);                       d += 2;                                                   } else {                                                      *(unsigned long long*) d = 0x3b00000032ULL | (LO);          d += 3;                                                   }                                                         }                                                       \n    #define W_CSI(dst) *(unsigned int*) dst = 0x5b001b; dst += 2;\n\n    unsigned short* diff_attr16(\n      unsigned short* d,\n      unsigned int fg,\n      unsigned int bg,\n      unsigned int diff_fg,\n      unsigned int diff_bg,\n      unsigned int ul,\n      unsigned int diff_ul\n    ) {\n      W_CSI(d)\n\n      if (!fg && !bg) {\n        *d++ = ';';\n      } else {\n        /* fg flags */\n        if (diff_fg >> 26) {\n          SGR_FLAG(fg, diff_fg, INVERSE, '7', '7' << 16)\n          SGR_FLAG(fg, diff_fg, BOLD, '1', '2' << 16)\n          //SGR_FLAG(fg, diff_fg, UNDERLINE, '4', '4' << 16) // covered by ext ul attribs\n          SGR_FLAG(fg, diff_fg, BLINK, '5', '5' << 16)\n          SGR_FLAG(fg, diff_fg, INVISIBLE, '8', '8' << 16)\n          SGR_FLAG(fg, diff_fg, STRIKETHROUGH, '9', '9' << 16)\n        }\n        /* fg color */\n        if (diff_fg & COLOR_MASK) d = set_color16(d, fg, '3');\n\n        /* bg flags */\n        if (diff_bg >> 26) {\n          SGR_FLAG(bg, diff_bg, ITALIC, '3', '3')\n          SGR_FLAG(bg, diff_bg, DIM, '2', '2')\n        }\n        /* bg color */\n        if (diff_bg & COLOR_MASK) d = set_color16(d, bg, '4');\n\n        /* ul ext attributes */\n        /* safety measure: check against HAS_EXTENDED in case we have spurious ext attrib values */\n        if (bg & HAS_EXTENDED) {\n          if (diff_ul & UNDERLINE_STYLE) {\n            *d++ = '4';\n            *d++ = ':';\n            *d++ = ((ul & UNDERLINE_STYLE) >> 26) + 48;\n            *d++ = ';';\n          }\n          if (diff_ul & COLOR_MASK) d = set_color16(d, ul, '5');\n        }\n      }\n      *(d - 1) = 'm';\n      return d;\n    }\n\n    unsigned int old_fg = 0;\n    unsigned int old_bg = 0;\n    unsigned int old_ul = 0;\n    unsigned int old_link = 0;\n\n    void reset(int fg, int bg, int ul, int link) {\n      old_fg = fg;\n      old_bg = bg;\n      old_ul = ul;\n      old_link = link;\n    }\n\n    // FIXME: how to get rid of the weird BCE hack?\n    void* line16(Cell *src, int length, unsigned short *dst) {\n      int cur_jmp = 0;\n      unsigned int bce = old_bg;\n      unsigned ul = old_ul;\n      unsigned link = old_link;\n\n      for (int i = 0; i < length;) {\n        Cell cell = src[i];\n\n        /**\n         * apply SGR differences\n         * We have to nullify HAS_EXTENDED due to its overloaded meaning,\n         * otherwise we would introduce nonsense jump/erase sequences here.\n         * SGR ext attributes for UL are covered by the explicit comparison,\n         * URL/hyperlink entry needs a separate control path (TODO).\n         */\n        unsigned bg = cell.bg & ~HAS_EXTENDED;\n        ul = *((unsigned int *) (4096 * 4) + i);\n        if (cell.fg != old_fg || bg != old_bg || ul != old_ul) {\n          /*\n            we are in the middle of jumped over cells,\n            thus still need to apply BG changes first\n           */\n          if (cur_jmp) {\n            if (old_bg != bce) {\n              W_CSI(dst)\n              dst = itoa16(cur_jmp, dst);\n              *dst++ = 'X';\n            }\n            W_CSI(dst)\n            dst = itoa16(cur_jmp, dst);\n            *dst++ = 'C';\n            cur_jmp = 0;\n          }\n          /* write new SGR sequence, advance fg/bg/ul colors */\n          dst = diff_attr16(dst, cell.fg, cell.bg, cell.fg ^ old_fg, cell.bg ^ old_bg, ul, ul ^ old_ul);\n          old_fg = cell.fg;\n          old_bg = bg;\n          old_ul = ul;\n        }\n\n        /* OSC 8 link handling */\n        link = *((unsigned int *) (4096 * 4) + (length + i));\n        if (link != old_link) {\n          if (old_link) {\n            // simply close old link - OSC 8 ; ; BEL\n            *(unsigned long long*) dst = 0x003b0038005d001bULL;   // ; 8 ] ESC\n            dst += 4;\n            *(unsigned int*) dst = 0x0007003b;   // BEL ;\n            dst += 2;\n          }\n          if ((cell.bg & HAS_EXTENDED) && link) {\n            dst = load_link(dst, link);\n            old_link = link;\n          } else {\n            old_link = 0;\n          }\n        }\n\n\n        /* text content handling */\n        if (cell.content & HAS_CONTENT_MASK) {\n          /*\n            we are in the middle of jumped over cells, thus apply cursor jump\n            we have to check here again in case there were no SGR changes\n           */\n          if (cur_jmp) {\n            if (old_bg != bce) {\n              W_CSI(dst)\n              dst = itoa16(cur_jmp, dst);\n              *dst++ = 'X';\n            }\n            W_CSI(dst)\n            dst = itoa16(cur_jmp, dst);\n            *dst++ = 'C';\n            cur_jmp = 0;\n          }\n          /* combined chars are written from JS (expensive?) */\n          if (cell.content & IS_COMBINED_MASK) {\n            // FIXME: preload combined in a single action similar to ext attribs?\n            dst = single_combined(dst, i);\n          } else {\n            /* utf32 to utf16 conversion */\n            unsigned int cp = cell.content & 0x1FFFFF;\n            if (cp > 0xFFFF) {\n              cp -= 0x10000;\n              *dst++ = (cp >> 10) + 0xD800;\n              *dst++ = (cp % 0x400) + 0xDC00;\n            } else {\n              *dst++ = cp;\n            }\n          }\n        } else {\n          /* empty cells are treated by cursor jumps */\n          cur_jmp++;\n        }\n\n        /* advance cell read position by wcwidth or 1 */\n        int width = cell.content >> WIDTH_SHIFT;\n        i += width ? width : 1;\n      }\n\n      /*\n        clear cells to the right if we have jumped over cells\n        and bce color != current bg\n       */\n      if (cur_jmp && old_bg != bce) {\n        W_CSI(dst)\n        dst = itoa16(cur_jmp, dst);\n        *dst++ = 'X';\n      }\n\n      return dst;\n    }\n    "},"memorySettings":{"descriptor":{"initial":1,"shared":false},"mode":"imported"}}